# Copyright 2020-2022 Lowdefy, Inc

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

_ref:
  path: templates/general.yaml.njk
  vars:
    pageId: blocks
    pageTitle: Blocks
    section: Concepts
    filePath: concepts/blocks.yaml
    content:
      - id: md1
        type: MarkdownWithCode
        properties:
          content: |
            A Lowdefy page is compiled out of an arrangement of blocks. Every HTML element of this page is rendered as a result of a block placed and configured on the page. Blocks make it simple for Lowdefy developers to create apps since they only have to decide which block type to use, where in the layout the block should render, and what the block should do by defining the block's `properties`. How a block implements these `properties` is up to the specific block type selected.

            Lowdefy offers a list of over 30 block types to cater for a wide range of use cases. All blocks are categorized according to their primary function:
            - `display` - Display page elements.
            - `input` - Modify a value in [`state`](/context-and-state).
            - `container` - Render other blocks into [`content areas`](/layout).
            - `list` - Render `content areas` and blocks for each element in the data array.

            When `state` updates or a requests call completes, the Lowdefy engine reevaluates all operators and rerenders blocks for which the operator evaluation is different from the previous render result. The result is _live updates_ to all blocks on a page. Operators can be used to build _live update_ logic into all block fields, except for the `id`, `type`, `areas` and `blocks` fields.

            The schema for a Lowdefy block is:

            - `id: string`: __Required__ - A unique identifier for a block. For `Input` blocks the block `id` sets the field key which the block will modify in `state`. Field _dot-notation_ can be used to express fields which are nested in objects or arrays.
            - `type: string`: __Required__ - The is the block type identifier and defines what block to used. The block type used must either be a default block type or must defined in your app's `plugins` configuration.
            - `properties: object`: All the settings passed to a block component. __Operators are evaluated__.
            - `areas: object`: Used to set the content areas and content layout settings for `container` and `list` blocks. See [layout](/layout) for more details on how to use `areas`.
            - `blocks: array`: A array of blocks to render to the default `content` area for `container` and `list` blocks. See [layout](/layout) for more details on how to use the `blocks` array.
            - `events: object`: Used to defined [`actions`](/events-and-actions) that run when the block triggers an [`event`](/events-and-actions).
            - `layout: object`: Used to define the [layout](/layout) properties for a block. __Operators are evaluated__.
            - `skeleton: object`: Used to overwrite a block's default loading behavior by rendering a skeleton. Any block types from [`@lowdefy/blocks-basic`](https://www.npmjs.com/package/@lowdefy/blocks-basic) and [`@lowdefy/blocks-loaders`](https://www.npmjs.com/package/@lowdefy/blocks-loaders) can be used in the skeleton definition, including sub-blocks.
            - `loading: boolean`: When true, renders the block in loading. If a `skeleton` is defined, it will be rendered, else the block's default loading behavior will be rendered.
            - `required: boolean | string`: For `input` blocks, whether or not a value is required in `state` when the [`Validate`](/Validate) action is called. Can be either a boolean or a string that is used as the validation error message . __Operators are evaluated__.
            - `style: css object`: Used to apply css style settings to the block's top level `div` element. __Operators are evaluated__.
            - `validate: array`: A list of validation tests to pass when the [`Validate`](/Validate) action is called. __Operators are evaluated__.
            - `visible: boolean`: Controls whether or not to render a block. Operators  are generally used here, and must evaluate to `false` to make the block invisible. Blocks with `visible: false` are excluded from `state`. __Operators are evaluated__.

            ## Block types

            Lowdefy has a list of default block types as defined in the Lowdefy docs. Most of the default Lowdefy blocks aim to cover a very generic implementation of the [Ant Design](https://ant.design/components/overview/) react component library, but are not limited to Ant Design since blocks are just simple React components. To use all the default block types, you can simply use the block `type` key, such as [`Button`](/Button), [`TextInput`](/TextInput), or [`Box`](/Box).

            ###### Default block type config example:
            ```yaml
            lowdefy: LOWDEFY_VERSION
            pages:
              - id: example_dashboard
                type: PageHeaderMenu
                blocks:
                  - id: basic_chart
                    type: Button
                    properties:
                      # ... Button details
            ```

            However, the default types can be overwritten or additional types can be defined as required. This is done by defining `plugins`.

            [TODO]: <> (# TODO: ADD PLUGIN EXAMPLE HERE)

            ## Input block validation

            All `input` block types maintain a value in [`state`](/context-and-state). This value is set to the field name matching the block `id`. Nested fields can be created by using _dot notation_ in the `id` to specify the field path.

            Client side field validation can be applied setting the `required` and / or `validate` block fields. Field validation is first evaluated when the [`Validate`](/Validate) action is invoked on a page.

            ##### required schema:

            `required` can be a `boolean` or `string` type. When `required: true` the field label will indicate this with a red dot for user feedback, and a value will have to be supplied in to the field in order to pass validation. If `required` is set to a `string`, this string will be used as the feedback message when the validation fails.

            ```yaml
            - id: name
              type: TextInput
              required: Please provide your name.
              properties:
                title: Name
            ```

            ##### validate schema:

            The `validate` field takes an `array` of test `objects` to evaluate before passing the field validation. This list of tests are evaluated sequentially, so the test that fails first will be used as the feedback message to the user.

            The schema for the validation test `objects`:
            - `pass: boolean`: __Required__ - The test that validates if this item passes or not. This is usually written as operators which evaluates to a `true` or `false`. __Operators are evaluated__.
            - `message: string`: __Required__ - The feedback message to the user if this validation tests fails. __Operators are evaluated__.
            - `status: enum`: The feedback type to present to the user. Option are `error` and `warning`. Default is `error`. __Operators are evaluated__.

            The following `validate` example first verifies that something was entered into the `email` field, then checks that the field passes a email regex validation using the [`_regex`](/_regex) operator:
            ```yaml
              - id: email
                type: TextInput
                validate:
                  - message: Please enter a email address.
                    status: error
                    pass:
                      _not:
                        _not:
                          _state: email
                  - message: Please provide a valid email address.
                    status: error
                    pass:
                      _regex: '^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$'
                properties:
                  title: Email
            ```

            ## Block events

            By default all blocks implement `onMount` and `onMountAsync` events. Both the `onMount` and `onMountAsync` events are triggered when the block is mounted. For the `onMount` event, the block only mounts when the event action chain is completed, however, for the `onMountAsync` event, the block will mount as soon as possible while the event actions complete execution.

            Apart from the `onMount` and `onMountAsync` events, most blocks also implement their own block specific events such as `onOpen` for [Modal](/Modal) or `onClick` for [Button](/Button). See the events tab on each block's documentation for more details.

            See [the events and actions page](/events-and-actions) for more details.

            ## Block loading

            Blocks will only start rendering when the `onInit` event has completed its actions. The `onMount` event on blocks will render blocks loading active. By default, some blocks will change behavior while it is in loading. For example, input blocks will be disabled during loading. The loading behavior of blocks can be controlled using the `loading` block property. Setting `loading` to `true` on a container or list block, will result in rendering all child blocks with loading active.

            Often it is useful to render a skeleton of blocks instead of the blocks' default loading behavior. When block definitions are provided to the `skeleton` property on a block, this `skeleton` definition will be rendered when loading is active. Any block types from [`@lowdefy/blocks-basic`](https://www.npmjs.com/package/@lowdefy/blocks-basic) and [`@lowdefy/blocks-loaders`](https://www.npmjs.com/package/@lowdefy/blocks-loaders) can be used as the skeleton definition, including sub-blocks.

            ##### Block `loading` and `skeleton` example:

            ```yaml
            pages:
              - id: page_one
                type: Box
                blocks:
                  # ...
                  - id: paragraph_one
                    type: Paragraph
                    loading:
                      _eq:
                        - _state: done
                        - false
                    skeleton:
                      type: SkeletonParagraph
                      properties:
                        lines: 1
                    properties:
                      content: Lorem ipsum dolor sit amet.
                  # ...
            ```

            ## TLDR
              - All user interfaces in Lowdefy are assembled out of blocks.
              #### Block types
              - There are four block categories: `display`, `input`, `container` and `list`.
              - Operators re-evaluate on every [`state`](/context-and-state)  update or as request calls complete. This allows blocks to _live update_.
              - Lowdefy has built in default block types, however this can be overwritten or extended with custom blocks by defining `plugins` on the Lowdefy config root.
              - `input` blocks maintain a value in `state` matching the block `id` key. _Dot notation_ applies to specify nested fields.
              #### Block validation
              - Field level input validation can be achieved by marking an `input` block as `required` or by specifying a list of `validate` tests.
              - Validation is invoked using the [`Validate`](/Validate) action.
              #### Block events
              - All blocks have`onMount` and `onMountAsync` events.
              - Each block implements it's own additional events such as `onClick` etc.
              #### Block loading
              - Some blocks gracefully handle a loading state while `onMount` events are being executed.
              - A block's default loading can be overwritten by defining custom `skeleton` settings on a block.

      - _ref:
          path: templates/navigation_buttons.yaml
          vars:
            previous_page_title: Context and State
            previous_page_id: context-and-state
            next_page_title: Layout
            next_page_id: layout
